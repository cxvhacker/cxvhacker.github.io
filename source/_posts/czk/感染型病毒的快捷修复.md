---
title: 感染型病毒的快捷修复
author: czk
categories:
- 感染型病毒清除
tags: 
- 感染型病毒
date: 2020-09-15

---

​	感染型病毒的运行时会将自身或自身的一部分加入到其它的程序中(exe或者dll)，从而实现对感染电脑的破坏和自身的传播.

​	由于感染型病毒的特征，我们在查杀感染型病毒时需要对其附加到宿主程序上的部分进行清除; 怎么样快速的正确还原出原始文件，也就是本篇的目的；

<!-- more -->



# 样本信息:

MD5: 369CCE2C078C33F996073FF4DC09D451
SHA1: BE1CEE51CB13F5687128236FA8E3B2FF3E04BB88





首先用lordPE看一下样本的入口点和区块信息;

正常PE一般只有一个.text段，入口点在第一个区块中; 这个样本的区块有几个重复了，而且入口点在第四个区块中，这是不正常的，可以确认一点PE入口点肯定被修改了；

![image-20200915163632128](/pic/czk/virusrepair/lordpe.png)



现在先不用IDA分析代码呢，试想一下感染型病毒的实现过程, 大体如下

​	枚举目录->判断PE类型->打开读取->保存原始信息->写入病毒代码->修改入口点；

中间可能用到的函数FindFirstFile,FindNextFile,CreateFile,ReadFile,WriteFile;

大体逻辑如下：

```
FindFirstFile

do

{

	if(hFile = CreteFile())
	{
		ReadFile(hFile,)
		...
		WriteFile(hFile,)
	}

}while(FindNextFile)
```



在IDA中验证一下:

IDA打开样本，在Import视图中查找相关函数,可以看到相关函数都存在；

![image-20200915165431665](/pic/czk/virusrepair/IDA_Import.png)

​	双击FindFirstFileA进入相关逻辑代码处，然后F5直接看伪代码(这个样本刚好能成功，如果不能就要看汇编了)

![image-20200915165731370](/pic/czk/virusrepair/FindFirstFile.png)

可以看到和预测逻辑大体不差，sub_4151d0应该是实现感染的逻辑了，传入的参数是遍历到的文件对应的文件句柄；

感染时为了后续还能正常执行原始PE文件，一般都会备份原始PE信息, 入口点一类的...

进入sub_4151d0后重点关注读取的文件数据；

![image-20200915170943182](/pic/czk/virusrepair/BackupOptionHeader.png)

一个if语句控制了整个函数逻辑, 并且传入了文件句柄,进入看一下;

![image-20200915171257139](/pic/czk/virusrepair/ReadOriPEHeader.png)



一层层的if判断逻辑，有PE有效性校验; 中间方框框中的，直接把0xf8大小的PE文件头读到全局buffer里面去了。。。

这还找什么PE入口点，一个PE所有的信息不都存在PEHeader中么，全给我了... 直接从这里恢复就行了



![image-20200915171726774](/pic/czk/virusrepair/oriPEHeader.png)



至此恢复原始文件的信息基本找齐，直接把数据写回PE头部对应位置就可以了，针对这个pe还要清除病毒代码，即第四个区块以后的。

针对这个样本，病毒做了什么了，具体感染细节就不一一分析了；

总之快速分析的关键就是根据相关函数定位到感染逻辑，仔细跟踪ReadFile后的数据处理；





