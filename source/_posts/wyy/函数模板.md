---
title: 函数模板
author: Wyy
categories:
- 模板
date: 2020-09-09 
excerpt: 函数模板提供一个种用来自动生成各种类型函数实例的算法，可以大大提高编程的效率。
---

### **函数模板产生背景**

有时候，强类型语言对于实现相对简单的函数似乎是个障碍。例如，虽然下面的函数min()的算法很简单。但是，强类型语言要求我们为所有希望比较的类型都实现一个实例：

```cpp
int min( int a, int b ) 
{
    return a < b ? a : b;
}

double min( double a, double b ) 
{
    return a < b ? a : b;
}
```

函数模板提供一个种用来自动生成各种类型函数实例的算法，程序员对于函数接中的全部或者部分类型进行**参数化** 。而函数体保持不变。如用一个函数的实现在一组实例上保持不变，并且每个实例都处理一种惟一的数据类型，如函数模板 min() 。

```cpp
template <typename Type>
	Type min(Type a, Type b)
{
    return a < b ? a : b;
}

int main()
{
    min(10,20);
    min(10.0,20.0);
    return 0;
}
```

关键字 template 总是放在模板的定义与声明的最前面。关键字后面是用逗号分隔的**模板参数表** ， 它用尖括号 <>  括起来。该列表是模板参数表，不能为空，模板参数可以是一个**模板类型参数** ， 它代表了一种类型；也可以是一个**模板非类型参数**，它代表了一个常量表达式。
模板类型参数由关键字 class 或 typename 后加一个标识符构成。在函数的模板参数表中，这两个关键字的意义相同。它们表示后面的参数名代表一个潜在的内置或用户定义的类型。

### 函数模板实例化

函数模板指定了怎样根据一组或更多实际类型或值构造出独立的函数。这个构造过程被称为模板实例化（template instantiation）。这个过程是隐式发生的，它可以被看作是函数模板调用或取函数模板的地址的副作用。

```cpp
template <typename Type, int size>
	Type min(Type (&r_array)[size])
{
    Type min_val = r_array[0];
    for(int i = 1; i < size; i++)
    {
        if (r_array[i] < min_val)
            min_val = r_array[i];
    }
    return min_val;
}
int ia[] = {10,7,14,3,25};
double da[6] = {10.2, 7.1, 14.5, 3.2, 25.0, 16.8};

#include<iostream>
int main()
{
    int i = min(ia);
    if( i ！= 3)
        std::cout << "int min() failed\n";
    else
        std::cout << "int min() ok\n";
    
    double d = min(da);
    if(d != 3.2 )
        std::cout << "double min() failed\n";
    else
        std::cout << "double min() ok\n";
    return 0;
}
```

调用 i = mian(ia);被实例化为下面的main()的整型实例，这里Type被int、size被5取代：

```cpp
int min(int (&r_array)[5])
{
    int min_val = r_array[0];
    for(int i = 1; i < 5; i++)
    {
        if (r_array[i] < min_val)
            min_val = r_array[i];
    }
    return min_val;
}
```

类似地，调用 double d = min(da)；也被实例化min()的实例，这里Type被double，size被6取代。

函数模板在取其地址时被实例化。

```cpp
template <typename Type, int size>
	Type min(Type (&p_array)[size])
{
    /* ... */
}
int (*pf)(int (&)[10]) = &min;
```

pf的类型是指向函数的指针，该函数有一个类型为int(&)[10]的参数。当min()被实例化时，该参数的类型决定了Type的模板实参的类型和size的模板实参的值。Type的模板实参为int，size的模板实参为10.被实例化的函数是min(int(&)[10])，指针pf指向这个模板实例。

### 函数模板实参推演

当函数模板被调用时，对函数实参类型的检查决定了模板实参的类型和值、这个过程被称为**模板实参推演**。

在模板实参推演期间决定模板实参的类型时，编译器不考虑函数模板实例的返回类型。例如：

```cpp
double da[8] = {10.3, 7.2, 14.0, 3.8, 25.7, 6.4, 5.5, 16.8};
int il = min(da);
```

min()的实例有一个参数，它是一个指向8个double的数据的指针。出该实例返回的值的类型是double型。该返回值先被转换成int型，然后再来初始化il。即使调用min()的结果被用来初始化一个类型的对象，也不会影响模板实参的推演过程。

要想成功地进行模板实参推演,函数实参的类型不一定严格匹配相应函数的类型。有三种类型转换是允许的：左值转换、限定转换和到一个基类（该类根据一个类模板实例化而来）的转换。

左值转换包括从左值到右值的转换、从数组到指针的转换或从函数到指针的转换。为说明左值转换是怎样影响实参推演过程的，让我们考虑min2()。

```cpp
template <typename Type>
	Type min2(Type* array, int size)
{
    Type min_val = array[0];
    for(int i = 1; i < size; i++)
    {
        if(array[i] < min_val)
            min_val = array[i];
    }
    return min_val;
}
```

下面用4个int的数组来作为第一个实参调用min2();

```cpp
int ai[4] = {12, 8, 73, 45};
int main()
{
    int size = sizeof(ai)/sizeof(ai[0]);
    min2(ai,size);
}
```

函数实参ai的类型是4个int 的数组，虽然这与相应的函数参数类型Type*并不严格匹配。但是因为允许从数组到指针的转换，所以实参ai在模板实参Type被推演之前被int *类型。最终被实例化的函数模板min2(int* * ,int)。

限定修饰转换把const或volatile限定修饰附加到指针上，我们考虑用函数min3()来说明，它的第一个函数参数的类型是const Type*。

```cpp
template <typename Type>
	Type min3(const Type* array, int size)
{
    // ...
}
int main()
{
    int *pi = &ai;
    int i = min3(pi, 4);
    return 0;
}
```

函数参数pi的类型是int指针，虽然与相应的函数类型const Type* 并不完全匹配。但是因为允许限定修饰转换，所以函数实参在模板实参被推演之前，就先被转换成const Type*类型了。然后Type的模板实参被推演为int，被实例化的函数模板是min3(const int *, int);

下面再来看一下一个基类的转换。如果函数参数的类型是一个类模板，且如果实参是一个类，它有一个从被指定为函数参数的类模板实例化而来的基类，则模板实参的推演就可以进行。

```cpp
template <typename Type>
	class Array
    {
        /*
        	...
        */	
    };

template <typename Type>
	class ArrayRc : public Array<Type>
    {
        /*
        	...
      	*/
    };

template <typename Type>
	Type min4(Array<Type> &array)
{
    Type min_val = array[0];
    for(int i=1; i < array.size(); ++i)
    {
        if(array[i] < min_val)
            min_val = array[i];
    }
    return min_val;
}

int main()
{
    ArrayRC<int> ia_rc(ia,sizeof(ia)/sizeof(int));
    min4(ia_rc);
    return 0;
}

```

函数实参ia_rc的类型是ArrayRC<int>,它与之相应的函数类型Array<Type>&并不完全匹配。因为类ArrayRC<int>有一个Array<int>的基类，而Array<int>是一个从被指定为函数参数的类模板实例化而来的类，并且派生类型的函数实参还可以被用来推演一个模板实参。被实例化的函数模板是min4(Array<int>&)。

 所以模板实参推演的通用算法如下：

1、 依次检查每个函数实参 以确定在每个函数参数的类型中出现的模板参数。
2 、如果找到模板参数 则通过检查函数实参的类型 推演出相应的模板实参。
3 、函数参数类型和函数实参类型不必完全匹配 下列类型转换可以被应用在函数实参上以便将其转换成相应的函数参数的类型;左值转换、限定修饰转换、从派生类到基类类型的转换 假定函数参数具有形式 T<args> T<args>&或 T<args>*
4 、如果在多个函数参数中找到同一个模板参数 则从每个相应函数实参推演出的模板实参必须相同。

### 显示函数模板实参

在某些情况下编译器不可能推演出实参的类型。像下面这个例子。

```cpp
template <typename T> T min5(T,T)(/* ... */)
unsigned int ui;

int main()
{
    //min(unsigned int,int); 错误，不能被实例化
    min(ui,1024);
    return 0;
}
```

在这种情况下，我们需要改变实参的推演机制，并使用**显示指定**模板实例。模板实参被显示指定在逗号分隔的列表中，用尖括号(<>,一个小于号和一个大于号)括起来，紧跟在函数模板实例的名字后面。例如min5()的调用可以重写为：min5<unsigned int>(ui,1024);

显式模板实参应该只被用在完全需要它们来解决二义性，或在模板实参不能被推演出来的上下文中使用模板实例时 。首先，让编译器来决定模板实参的类型和值是比较容易的。其次，如果我们通过修改程序中的声明来改变在函数模板实例调用中的函数实参的类型，则编译器会自动用不同的模板实参实例化函数模板，而无需我们做任何事情。另一方面，如果我们指定了显式模板参数，则必须检查显式模板实参对于函数实参的新类型是否仍然合适 所以建议在可能的时候省略显式模板实参。

### 函数模板编译模式

c++模板编译模式有两种分别是**包含模式**和**分离模式**。

在包含模式下，每个模板被实例化的文件中包含函数模板定义，并且往往放在头文件中，像内联函数那样。在头文件中提供函数模板定义有几个缺点。函数模板体 描述了实现细节，对于这些细节，用户可能想忽略或者我们希望隐藏起来不让用户知道，实际上如果函数模板的定义非常大， 那么在头文件中给出的细节层次有可能是不可接受的。而且，在多个文件之间编译相同的函数模板定义增加了不必要的编译时间。

在分离编译模式下，函数模板的声明被放在头文件中。在这种模式下函数模板声明和定义的组织方式与程序中的非内联函数的声明和定义组织方式相同。

```cpp
//model.h
template <typename Type> Type min(Type t1,Type t2);

//model.cpp 
export template <typename Type>
    Type min(Type t1, Type t2){/* ... */}

//user.cpp
#include "model.h"

int i,j;
double d = min(i,j);
```

模板 min()被定义成一个可导出的模板 关键字 export 告诉编译器在生成被其他文件使用的函数模板实例时可能需要这个模板定义。

注意：有些编译器实现可能不要求用关键字 export 有些实现可能支持下列语言扩展非导出的函数模板定义可能只出现在一个程序文本文件中，在其他程序文本文件中用到的实例仍然被正确地实例化；但是，这种行为只是一个扩展。如果在模板被实例化之前只有函数模板的声明在程序文本文件中可见，那么，标准 C++要求用户把函数模板定义标记为 export。

在程序中，一个函数模板只能被定义为 export 一次。不幸的是，因为编译器每次只处理一个文件，所以它不能检测到一个函数模板在多个文本文件中被定义为 export 的情况。如果发生了这样的事情，下列行为就有可能随之发生：
1、可能产生一个链接错误 指出函数模板在多个文件中被定义。
2、编译器可能不只一次地为同一个模板实参集合实例化该函数模板，由于函数模板实例的重复定义，这会引起链接错误。
3、编译器可能用其中一个 export 函数模板定义来实例化函数模板，而忽略其他定义。

所以，在程序中提供多个 export 函数模板的定义不一定会产生错误。我们必须小心谨慎地组织程序，以便把 export 函数模板定义只放在一个程序文本文件中。

分离模式使我们能够很好地将函数模板的接口同其实现分开，进而组织好程序，以便把函数模板的接口放到头文件， 而把实现放在文本文件中。但是，并不是所有的编译器都支持分离模式，即使支持也未必总能支持得很好。支持分离模式需要更复杂的程序设计环境，所以它们不能在所有 C++编译器实现中提供。

### 函数模板显式特化

我们并不总是能够写出对所有可能被实例化的类型都是最合适的函数模板。在某些情况下， 我们可能想利用类型的某些特性，来编写一些比模板实例化的函数更高效的函数。

```cpp
//通用模板定义
template <typename T>
	T max(T t1, T t2)
{
    return (t1 > t2 ? t1:t2);
}

template<> const char* max<const char*>(const char* s1, const char* s2)
{
    return (strcmp(s1,sw2) > 0 ? s1 : s2);
}
```

在有些文件中,函数模板被根据通用模板定义实例化,而在其他文件中 对同一模板实参的集合却被特化。

```cpp
// max.h
template <typename Type>
	Type max(Type t1, Tpye t2){/* ... */}

// file1.cpp
#include <iostream>
#include "max.h"
void another();
int main()
{
    const char* p = max("hello","world");
    std::cout << "p:" << p << std::endl;
    another();
    return 0;
}

//file2.cpp
#include <iostream>
#include <cstring>
#include "max.h"
template<> const char* max<const char*>(const char* s1, const char* s2){/* ... */}
void another()
{
    const char* p = max("hi","again");
    std::cout << "p:" << p << std::endl;
    return 0;
}
```

上面的程序由两个文件构成 在 file1.cpp中 没有显式特化 max(const char *,const char * )的声明,函数模板被根据通用模板定义实例化。在file2.cpp 中声明了显式特化，调用 max("hi","again")就会调用该显式特化。因为同一程序在一个文件中实例化了函数模板实例 max(const char * ,const char * ) 而在另一个文件中又调用了这显式特化 所以这个程序是非法的。为了补救这个问题，显式特化的声明必须在文件 file1.cpp 中 max(const char * ,const char *)调用之前被给出。

### 重载函数模板

```cpp
template <typename Type>
	Type min(const Array<Type>&, int);

template <typename Type>
	Type min(const Type*, int);

template <typename Type>
	Type min(Type , Type);
```

上面给出的函数模板min()的三个有效的重载声明，重载的函数模扳可能会导致二义性，所以在使用函数模板重载时要考虑会不会导致二义性。

### 函数模板示例

```cpp
#include "Array.h"
#include <iostream>

template <class Type>
    Type min( Type a, Type b )
{
    return a < b ? a : b;
}

template <class elemType>
    void swap( Array<elemType> &array, int i, int j )
{
    elemType tmp = array[ i ];
    array[ i ] = array[ j ];
    array[ j ] = tmp;
}

template <class elemType>
    void display( Array<elemType> &array )
{
    std::cout << "< ";
    for ( int ix = 0; ix < array.size(); ++ix )
        std::cout << array[ix] << " ";
    std::cout << ">\n";
}

template <class elemType>
    void sort( Array<elemType> &array, int low, int high )
{
    if ( low < high )
    {
        int lo = low;
        int hi = high + 1;
        elemType elem = array[lo];
        for (;;)
        {
            while ( min( array[++lo], elem ) != elem && lo < high ) ;
            while ( min( array[--hi], elem ) == elem && hi > low ) ;
            if (lo < hi)
                swap( array, lo, hi );
            else
                break;
        }
        swap( array, low, hi );
        sort( array, low, hi-1 );
        sort( array, hi+1, high );
    }
}

#include <iostream>
#include <string>
#include "Array.h"

double da[10] = { 26.7, 5.7, 37.7, 1.7, 61.7, 11.7, 59.7, 15.7, 48.7, 19.7 };
int ia[16] = { 503, 87, 512, 61, 908, 170, 897, 275, 653,448, 426, 154, 509, 612, 677, 765, 703 };
string sa[11] = {"a", "heavy", "snow", "was", "falling", "when","they", "left", "the", "police", "station" };

int main() 
{
    // 调用构造函数初始化 arrd
    Array<double> arrd( da, sizeof(da)/sizeof(da[0]) );
    // 调用构造函数初始化 arri
    Array<int> arri( ia, sizeof(ia)/sizeof(ia[0]) );
    // 调用构造函数初始化 arrs
    Array<string> arrs( sa, sizeof(sa)/sizeof(sa[0]) );
    std::cout << "sort array of doubles (size == " << arrd.size() << ")" << std::endl;
    sort( arrd, 0, arrd.size()-1 );
    display(arrd);
    std::cout << "\sort array of ints (size == " << arri.size() << ")" << std::endl;
    sort( arri, 0, arri.size()-1 );
    display(arri);
    std::cout << "\sort array of strings (size == " << arrs.size() << ")" << std::endl;
    sort( arrs, 0, arrs.size()-1 );
    display(arrs);
    return 0;
}
```

