---
title: 行为设计模式-观察者模式
author: Wyy
categories:
- 设计模式
date: 2020-05-28 
excerpt: 观察者模式作为设计模式大家庭中最重要的一个

---



## 什么是观察者模式

观察者模式定义了对象间一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新。为了能够更好的理解观察者模式，先来举一个例子。比如说在拍卖会上，大家相互叫价，拍卖师会根据竞价者给出的价格不断的更新数据，然后通知给其它竞价者当前的竞价。这个例子就很好的体现了观察者模式特性。对于观察者模式而言，肯定有观察者和被观察者之分；拍卖师就充当了被观察者的角色，竞价者就充当了观察者的角色。		

**观察者模式（Observer）**，又叫**发布-订阅模式（Publish/Subscribe）**、**依赖(Dependents)**。其结构如下图所示：

![](/pic/wyy/observer/structure_chart.png)

**Subject（目标）**，目标知道它的观察者，可以有任意多个观察者观察同一个目标，内部提供注册和删除观察者对象的接口。**Observer（观察者）**，为那些在目标发生改变时需获得通知的对象定义一个更新接口。**ConcreteSubject（具体目标）**，将有关状态存入各ConcreteObserver对象； 当它的状态发生改变时, 向它的各个观察者发出通知。**ConcreteObserver（具体观察者)**，维护一个指向ConcreteSubject对象的引用；存储有关状态，这些状态应与目标的状态保持一致；实现Observer的更新接口以使自身状态与目标的状态保持一致。

## 观察者模式的动机

在开发一个系统之前，我们会把这个系统分割成一系列相互协作的类；但是有一个常见的副作用：需要维护相关对象之间的一致性。我们不希望为了一致性而使各类紧密耦合，因为这样降低了它们的可重用性。

例如，许多图形界面工具箱将用户应用的界面表示与底下的数据分离。如下图所示：

![](/pic/wyy/observer/table.png)

从中可以看到定义应用数据的类和负责界面表示的类可以各自独立地服用，当然它们也可以一起工作。一个表格对象和一个柱状图对象可以使用不同的表示形式描述同一个应用数据对象的信息。表格对象和柱状图对象互相并不知道对方的存在，这样你可以根据需要单独复用表格或柱状图。但在这里是它们表现的似乎互相知道。当用户改变表格中的信息时，柱状图能立即反应这一变化，反过来也是如此。

## 观察者模式的优缺点

**目标和观察者间的抽象耦合**  一个目标所知道的仅仅是它有一系列观察者 , 每个都符合抽象的Observer类的简单接口。目标不知道任何一个观察者属于哪一个具体的类。这样目标和观察者之间的耦合是抽象的和最小的。因为目标和观察者不是紧密耦合的 , 它们可以属于一个系统中的不同抽象层次。一个处于较低层次的目标对象可与一个处于较高层次的观察者通信并通知它 , 这样就保持了系统层次的完整。如果目标和观察者混在一块 , 那么得到的对象要么横贯两个层次 (违反了层次性), 要么必须放在这两层的某一层中(这可能会损害层次抽象)。

**支持广播通信** 不像通常的请求, 目标发送的通知不需指定它的接收者。通知被自动广播给所有已向该目标对象登记的有关对象。目标对象并不关心到底有多少对象对自己感兴趣 ;它唯一的责任就是通知它的各观察者。这给了你在任何时刻增加和删除观察者的自由。处理还是忽略一个通知取决于观察者。

**意外的更新** 因为一个观察者并不知道其它观察者的存在 , 它可能对改变目标的最终代价一无所知。在目标上一个看似无害的的操作可能会引起一系列对观察者以及依赖于这些观察者的那些对象的更新。此外 , 如果依赖准则的定义或维护不当，常常会引起错误的更新 , 这种错误通常很难捕捉。简单的更新协议不提供具体细节说明目标中什么被改变了 , 这就使得上述问题更加严重。如果没有其他协议帮助观察者发现什么发生了改变，它们可能会被迫尽力减少改变

## 观察者模式实现—拍卖软件

首先要定义一个抽象类Observer接口：

```cpp
class Observer
{
public:
	virtual ~Observer() = default;
	virtual void update() = 0;
};
```

类似的，定义一个抽象类Subject接口:

```cpp
class Subject
{
public:
	virtual ~Subject() = default;
	virtual void attach(Observer* observer) = 0;
	virtual void detach(Observer* observer) = 0;
	virtual void data_change(Data data) = 0;
	virtual void notify() = 0;
};
```

实现具体的目标-Auction

```cpp
class Auction :public Subject
{
public:
	Auction(){};
	~Auction(){};

public:
	virtual void attach(Observer* observer);
	virtual void detach(Observer* observer);
	virtual void data_change(Data data);
	virtual void notify();
	virtual std::string get_bid_info();

private:
	std::set<Observer*> _observer_set;
	Data _data;
};

void Auction::attach(Observer* observer)
{
	_observer_set.insert(observer);
}

void Auction::detach(Observer* observer)
{
	auto find = _observer_set.find(observer);
	if (find != _observer_set.end())
		_observer_set.erase(find);
}

void Auction::data_change(Data data)
{
	_data.observer_name = data.observer_name;
	_data.price = data.price;
	notify();
}

void Auction::notify()
{
	auto iters = _observer_set.begin();
	while (iters != _observer_set.end())
	{
		(*iters)->update();
		iters++;
	}
}

std::string Auction::get_bid_info()
{
	return 	_data.observer_name + "出价:" + std::to_string(_data.price) + "$";
}
```

下面具体实现观察者-Bidder，Bidder会创建一个窗口，窗口内会添加一个编辑框，一个按钮，窗口背景就是所拍卖的物品，当竞价者在输入框中输入价格，点击按钮就就会通知拍卖人员我的价格更高，需要更新数据。窗口创建不是此次学习的重点，就不再累述。

```cpp
class Bidder : public Observer
{
public:
	Bidder(Subject* auction, std::string class_name, std::string bidder_name);
	~Bidder();
	virtual void update();
	LRESULT win_func(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
	void _create_dialog(std::string class_name, std::string bidder_name);
	void _notice_subject(DWORD num);

private: 
	std::string _bidder_name;
	std::string _notice;
	Subject* _subject;
	HDC _hdc_mem;
	HWND _main_wind;
	HWND _button;
	HWND _edit;
};

Bidder::Bidder(Subject* subject, std::string class_name, std::string bidder_name)
{
	_subject = subject;
	_bidder_name = bidder_name;
	_create_dialog(class_name, bidder_name);
	_subject->attach(this);
}

Bidder::~Bidder()
{
	_subject->detach(this);
}

void Bidder::update()
{
	_notice = dynamic_cast<Auction*>(_subject)->get_bid_info();
	SendMessage(_main_wind, WM_PAINT, 0, 0);
}

void Bidder::_notice_subject(DWORD num)
{
	Data data;
	data.observer_name = _bidder_name;
	data.price = num;
	_subject->data_change(data);
}
```

运行结果：

![](/pic/wyy/observer/result.png)