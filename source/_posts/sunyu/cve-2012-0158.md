---
title: CVE-2012-0158简单分析和利用
author: 此生汝梦 
categories:
- 漏洞分析
tags: 
- cve-2012-0518
date: 2020-07-02
excerpt: 对cve-2012-0158这个漏洞的分析学习和简单利用
---
# 前言
　　CVE-2012-0158是存在于office的MSCOMCTL.OCX组件中的一个栈溢出漏洞。
　　因为多个版本的Office中的该组件都存在该漏洞，所以被恶意文档的作者们广泛利用。
　　该篇文章用于快速理解cve-2012-0158这个漏洞，所以对于具体原理并没有进行过多的赘述，使用的样本也为验证POC。如果想要深入了解其具体机制，可以参考文章末尾的链接。
# 分析环境与工具
* 操作系统：
　windos7 专业版(64位)
* 软件：
　Office Professional Plus 2007 (Simplified Chinese)
* 工具：
　x32dbg，IDA，Immunity Debugger（mona插件）

# 漏洞分析
## 获取POC
　文件MD5:15552F40076D67AF066391D03AC173ED
　可从微步等平台自行下载
　注意：该样本为验证POC，运行到溢出点时会直接崩溃。
## 复现漏洞
直接执行poc
![ALt text](/pic/sunyu/cve-2012-0158/图片1.png)
　从图中可以看到word程序直接崩溃了（工作环境中利用该漏洞的样本此时已经开始运行恶意代码了）。
　此处报出的错误为c0000005（访问了无权限的内存），这是该验证POC刻意为之，将转向跳板指令的地址改成了41414141，造成了访问异常。
![ALt text](/pic/sunyu/cve-2012-0158/图片2.png)
　图中为附加到打开POC的word进程中时，调试器X32dbg中的情形，注意eip和最底下的报错(eip正常利用时此处应该指向跳板指令jmp esp)，结合该样本的特点确定此时到达溢出点附近。
## 分析
### 附加word进程，以便调试POC
总共有两种方法。
　第一种方法：
　　先打开word程序，类似于新建word文档。
![ALt text](/pic/sunyu/cve-2012-0158/图片3.png)
　　此时打开时X32dbg（一定要选x32，不然找不到word进程），对word进程进行附加
![ALt text](/pic/sunyu/cve-2012-0158/图片4.png)
　　附加后调试器会将word进程阻塞，摁F9让其继续运行.
　　此时回到word界面，通过"打开"的方式打开POC，或者直接将poc文档拖进word文档编辑区，使poc运行起来。
![ALt text](/pic/sunyu/cve-2012-0158/图片5.png)
　　运行后，x32DBG如上面一样因eip无效而报出c0000005错误（访问了无权限的内存）暂停下来，等待处理。
　第二种方法：
　　因为之前打开过一次poc,所以当我们再次打开时，word可能会提示上次打开此文档时出现错误是否要进行一些处理以便能对数据进行处理。
![ALt text](/pic/sunyu/cve-2012-0158/图片6.png)
　　在此时使用x32DBG对word进程进行附加，摁F9使进程继续运行，然后在word提示中点击"打开"按钮，便可调试poc了
### 确定溢出函数
　　在此前通过查找资料已经可以确定cve-2012-0158是个栈溢出漏洞，所以使用传统栈溢出的思想来分析栈。
![ALt text](/pic/sunyu/cve-2012-0158/图片7.png)
#### 1.栈溢出利用原理：
　　正常情况下栈未溢出时，系统通过当前函数的返回地址，返回到上层函数中调用当前函数的下一个指令处继续执行。
　　但是当栈溢出时，当前函数的栈内的某个变量数据突破限制，覆盖了当前函数的返回地址，那么当函数返回时，就不会返回到上层函数中调用当前函数的下一个指令处，而是返回到原本存储返回地址处现在所存的地址继续执行指令，这样一来就可以通过精心构造溢出数据，来使函数返回到我们指定的地址执行我们指定的指令。
　　通常情况下是使返回地址指向指令jmp esp，这样以来当函数返回后就会跳到esp处执行，而且此时的esp所指向的位置就是上层函数所使用的堆栈的栈顶，正好位于可以溢数据的破坏范围内，所以可以通过精心构造如上图所示结构的溢出数据来达到执行shellCode的目的
　　溢出数据包含4部分：第一部分滑块，用于填充溢出点前面的数据；第二部分，跳板指令地址，用于覆盖溢出点，使函数返回时执行指定的jmp esp命令；第三部分，用于弹栈的数据，用于应对函数返回指令ret n ;第四部分，执行完跳板指令jmp esp后到达的位置，此处填写ShellCode
#### 2.寻找栈中可用的信息
![ALt text](/pic/sunyu/cve-2012-0158/图片8.png)
　　如图中栈区红框所示，可以大致看出溢出数据的4个部分，从栈值41414141处往上为当前函数所用栈区（到哪里为止并不清楚），从esp处往下为上层函数所用栈区（到哪里为止并不清楚）
　　因为esp往下很可能已经被shellCode所破坏所以暂且不管，往上看，观察当前函数所用栈区部分。
![ALt text](/pic/sunyu/cve-2012-0158/图片9.png)
　　如图红框部分，从溢出点往上看不远就有一个没有被破坏的返回地址，猜测应该为当前函数内部调用的函数，就算不是也至少在执行流程上距离当前函数不远。
#### 3.验证猜想
　　找到的返回地址275C8A0A处下软件断点，然后重新触发漏洞，成功在断点处断下，猜想成功一半。
　　此时观察栈，可以发现，栈已经被溢出数据破坏，由此可以猜测破坏栈的过程很可能就在断点断下前执行的最后一个函数中，即"mscomctl.275C876D"中。
![ALt text](/pic/sunyu/cve-2012-0158/图片10.png)
　　在275C8A05处下断点，重新触发漏洞，观察"mscomctl.275C876D"运行前后栈的变化
运行前：
![ALt text](/pic/sunyu/cve-2012-0158/图片11.png)
运行后：
![ALt text](/pic/sunyu/cve-2012-0158/图片12.png)
　　由此确定溢出函数为mscomctl.275C89C7，溢出点在mscomctl.275C876D中，这两个函数均为mscomctl组件的函数
### 静态分析mscomctl函数
　　在x32dbg的内存布局中查看mscomctl的文件名为mscomctl.ocx。
![ALt text](/pic/sunyu/cve-2012-0158/图片13.png)
　　通过Everything查找该文件
![ALt text](/pic/sunyu/cve-2012-0158/图片14.png)
1.找到函数
　　通过查看pe头，该库没有随机基址，ida打开后其内部数据对应地址与X32dbg中相同，所以直接跳转到275C876D。
![ALt text](/pic/sunyu/cve-2012-0158/图片15.png)    
　　在这张图可以很明显看到一个危险函数qmemcpy。
　　对这个qmemcpy的参数进行分析，发现参数１是由上层函数传过来的，而且是上层函数的临时变量，使用的上层函数的栈内存。
![ALt text](/pic/sunyu/cve-2012-0158/图片16.png)
　　如果此时使用qmemcpy向参数1位置复制超量数据，超过上层函数中对该变量的内存大小定义，那么就会造成栈溢出。
　　继续分析剩下的两个参数，第二个参数lpMema是通过第三个参数dwBytes的值来确定大小的堆内存地址，然后通过是一个未知函数(标记为func_1)写入内容，暂时放过。第三个参数dwBytes为上层函数传入，用于控制复制数据的数。
　　猜测向qmemcpy第二个参数lpMema中写入数据的函数fun_1，为读取mscomctl.275C876D第二个参数lpMema_中的数据到时fun_1的参数1中。
　　如果上述猜测成立，那么mscomctl.275C876D这个函数的功能为从参数2中复制指定数量的数据到参数1，复制数据量由参数3和参数2的数据结构中的某一项共同限制（在执行qmemcpy前需从mscomctl.275C876D的参数2中读取一个数值，与参数3进行对比，相等才继续进行）。
![ALt text](/pic/sunyu/cve-2012-0158/图片17.png)
　　从函数mscomctl.275C89C7中可以看到，先是使用未溢出的mscomctl.275C876D从bstrString这个数据结构中读取0xc字节的数据，然后判断前8个字节为"Cobj"和后4个字节即溢出的mscomctl.275C876D函数的第三个参数dwBytes大于等于8，如果二者全满足，则执行可能造成溢出的mscomctl.275C876D。
　　通过观察IDA解析的mscomctl.275C89C7的栈结构可以看出，溢出的mscomctl.275C876D的第一个参数最多只能占8个字节，否则就会造成栈溢出，所以先前判断中的大于等于8实际上应该为小于等于8才对。
　　由此可以推断出cve-2012-0158的形成原因：**mscomctl.275C89C7在使用mscomctl.275C876D前进行长度验证时，把小于等于8写成了大于等于8，所以当传入数据长度过长就可能造成栈溢出**。
### 查阅资料验证猜想
　　通过网上搜索找到了早期的mscomctl.ocx早期符号（符号和对应的文件下载地址在文章末尾的链接中），加载符号后查看IDA发现mscomctl.275C89C7为函数CObj::Load，mscomctl.275C876D为函数ReadBytesFromStreamPadded，未知函数fun_1为pMem->lpVtbl->Read
![ALt text](/pic/sunyu/cve-2012-0158/图片18.png)
![ALt text](/pic/sunyu/cve-2012-0158/图片19.png)
    fun_1的功能的确为从指定对象中读取指定长度数据，所以上述猜想成立，对比网上众多分析，也基本确定猜想成立。
　　在这里有个阴谋论的猜想，这个漏洞应该微软刻意留下的，第一，将小于等8写成了大于等于8这是种低级且严重的错误，第二，通过查阅资料发现，正常产生的对象参数dwBytes的值和V7的值恒为8，正常使用时基本不可能发现该处漏洞。
#  漏洞利用
　　这个漏洞不仅仅只适用于rtf格式的文件，还适用于如doc / rtf / xls / docx，不过这里主要讲一下rtf格式如何利用。
　　通过前面的内容可以知道，这个漏洞是需要对某个嵌入到文档中的特定对象进行修改才能触发的，不过……经过一通胡乱操作之后，也没搞明白怎么插入这个对象，不过倒是想到了一个感染其他文档的方式。
## 确定溢出对象
　　使用rtfobj查看POC，发现POC中溢出的的对象为ListView对象
![ALt text](/pic/sunyu/cve-2012-0158/图片20.png)
## 简单利用
　　listView对象的插入方式比较隐秘，参考的文章中有用VBA宏来生成这个对象的方式，但那时针对excel文档，在rtf中没有插入宏的选项。
　　针对rtf类型的文档，在这里分享一个快捷的类似于"感染"的利用方式。
　　使用Notepad++打开POC，将修改后的对象（如何修改后面会讲到），复制出来，如下图所示选中的部分（阴影部分），然后用Notepad++打开想要"感染"的rtf文档，将复制的数据粘贴到，下图底部所示位置，也就时最后一个"}"前面。保存后再打开文档，就会可以执行构造的shellCode了。
![ALt text](/pic/sunyu/cve-2012-0158/图片21.png)
## 修改对象
　　根据上面提到栈溢出利用原理，对于POC中的对象我们只需要修改3个部分，第一部分修改两个8282（这两个个值默认为8，POC中将其修改为8282才造成了栈溢出）为0x1C+shellCode长度，这部分其实都不用改，0x8282-0X1C的长度足以放下大多数的shellCode。第二部分修改41414141为跳板指令地址，第三部分为shellCode
### 确定大小端存储
　　如果要修改溢出对象中的数据，则一定要确定对象内部数据是小端存储，还是大端存储，这里可以通过修改41414141来确定，将对象中的41414141改为41414144（直接搜字符串41414141即可，判断其前方24个字符前是否为8282000082820000(小端存储)或0000828200008282(大端存储)，即可找到对应的位置），然后触发漏洞，查看X32dbg中的eip。
![ALt text](/pic/sunyu/cve-2012-0158/图片22.png)
　　eip为44414141，由此可以确定其内部存储为小端存储。
### 修改第一部分-溢出长度
　　直接搜8282或者搜"Cobj"这个标示字符串对应的16进制436F626A64（在程序判断的是"jboC"在文档对应的小端存储就是"Cobj"），其后3个字节（6个字符）即为需要修改的部分8282000082820000，在这里可以不改，该0x8282-0x1c这个长度足够写shellcode，如果要压缩对象体积则改为0x1C+shellCode长度,然后将多余的0删除即可。
### 修改第二部分-跳板指令
* 使用Immunity Debugger的Mona插件寻找合适的跳板指令
　　Immunity Debugger这个软件并不自带Mona插件，需要自行下载，安装完Immunity Debugger后将Mona.py放到Immunity Debugger安装目录下的PyCommands文件夹内，然后重启Immunity Debugger，附加到word进程中。
　　在Immunity Debugger界面最下方的输入框内输入命令"!mona modules"列出模块列表。
![ALt text](/pic/sunyu/cve-2012-0158/图片23.png)
　　其中Rebase指重启后基址是否会变，SafeSEH指异常处理的安全验证，ASLR指加载时启用随机基址，NXCompat指EDP数据执行保护，OS DLL 指系统DLL
　　在这堆模块中找到Rebase,SafeSEH,ASLR,NXCompat,OS DLL这五项分别为False,False,False,False,True的模块。
　　其中Rebase，ASLR，OS DLL是为了确保找到的跳板指令地址固定不变，SafeSEH，NXCompat是为确保shellcode能在栈中执行。
　　最后找到了"6.00.9815 [MSVBVM60.DLL] (C:\Windows\system32\MSVBVM60.DLL)"
　　继续执行指令"!mona find -s "\xff\xe4" -m msvbvm60.dll"，这行指令的意思时在msvbvm60.dll中查找"jmp esp"的机器码"\xff\xe4"。
![ALt text](/pic/sunyu/cve-2012-0158/图片24.png)
　　图中的PAGE_EXECUTE_READ,PAGE_READONLY指的是机器码所在内存页的属性，这里要选PAGE_EXECUTE_READ，页面可读可执行，如果选PAGE_READONLY，页面只读，跳过去执行指令时还是会报错。
![ALt text](/pic/sunyu/cve-2012-0158/图片25.png)
　　所以最后确定的跳板指令地址为729A0535
* 修改地址
　　将41414141修改729A0535的小端存储形式35059a72,然后验证一下
![ALt text](/pic/sunyu/cve-2012-0158/图片26.png)
![ALt text](/pic/sunyu/cve-2012-0158/图片27.png)
![ALt text](/pic/sunyu/cve-2012-0158/图片28.png)
　　修改成功，成功跳转到栈顶准备执行栈中写入的指令。
### 修改第三部分-shellcode
　　这里要注意的一点时，mscomctl.275C89C7函数在返回时使用的指令是ret 8即先从栈中弹出一个地址然后跳转到这个地址继续执行指令，同时再从栈中弹出8个字节。所以写入shellCode的位置应该在跳板指令后8字节（16个字符）之后。
![ALt text](/pic/sunyu/cve-2012-0158/图片29.png)
　　这里的shellcode的用处是弹出系统自带的计算器（偷了个懒，这段shellcode提取自Kali Linux下用metasploit 生成的CVE-2012-0158弹计算器的样本）。
　　运行效果为打开修改后的word文档后，word自动关闭，并弹出计算器，这里不好截图，就不放图了。
# 参考链接
　　1.安全客-永远的经典：CVE-2012-0158漏洞分析、利用、检测和总结 https://www.anquanke.com/post/id/91643#h2-5
　　2.维一零《CVE-2012-0158（ms12-027）漏洞分析与利用》 https://weiyiling.cn/one/cve_2012_0158_ms12-027
　　3.维一零《手把手教你如何构造office漏洞EXP（第一期）》 http://bobao.360.cn/learning/detail/3003.html
# 文章中用到的附件
链接：https://pan.baidu.com/s/1yuetOzfSCMGkBAQslRf1qQ 
提取码：5vhm